# 🛶 Raft Consensus Implementation in Go

This is a basic implementation of the Raft consensus algorithm in Go, using gRPC for communication between nodes.

---

## 🏗️ Project Structure

```
.
├── raft/                 # Raft core logic
│   └── raft.go
├── proto/                # Protocol Buffers definitions
│   ├── message.proto
│   └── message.pb.go        # Generated by protoc
├── main.go               # Starts nodes
└── README.md             # This file
```

---

## 📦 Prerequisites

* [Go 1.18+](https://golang.org/dl/)
* [protoc](https://grpc.io/docs/protoc-installation/)
* `protoc-gen-go` and `protoc-gen-go-grpc`

Install protobuf plugins:

```bash
go install google.golang.org/protobuf/cmd/protoc-gen-go@latest
go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest
```

Make sure `$GOPATH/bin` is in your `PATH`.

---

## 📡 Generating gRPC Code

Run this from the root of your project:

```bash
protoc --go_out=. --go-grpc_out=. proto/node.proto
```

---

## 🚀 Running the Nodes

In `main.go`, you can start multiple Raft nodes with different addresses.

Example setup for 3 nodes:

```go
func main() {
	peers := []string{"localhost:5001", "localhost:5002", "localhost:5003"}

	node1 := raft.NewNode(1, "localhost:5001", peers)
	node2 := raft.NewNode(2, "localhost:5002", peers)
	node3 := raft.NewNode(3, "localhost:5003", peers)

	go node1.Run()
	go node2.Run()
	go node3.Run()

	select {} // block forever
}
```

Run the project:

```bash
go run main.go
```

You should see the nodes communicating and one being elected as the leader.

---

## 📜 Proto Definition (`proto/node.proto`)

```proto
syntax = "proto3";

package proto;

service NodeRegistration {
  rpc RegisterNode (NodeInfo) returns (RegisterResponse);
  rpc GetNodes (Empty) returns (NodeList);
  rpc SendHeartBeat (Signal) returns (Signal);
  rpc RequestVote (RequestVoteArgs) returns (RequestVoteReply);
}

message Empty {}

message Signal {
  bool flag = 1;
}

message NodeInfo {
  string id = 1;
  string addr = 2;
}

message RegisterResponse {
  string message = 1;
}

message NodeList {
  repeated NodeInfo nodes = 1;
}

message RequestVoteArgs {
  string candidateId = 1;
  int32 candidateTerm = 2;
}

message RequestVoteReply {
  bool voteGranted = 1;
}
```

---

## 🛠️ Features

* Leader election using randomized timeouts
* Heartbeat signals from leader to followers
* Peer-to-peer connection via gRPC
* Basic vote request handling

---

## 🧱 To Do / Next Steps

* Log replication
* Commit indexing
* Persistent state storage
* Failure recovery & snapshots

---

## 📃 License

MIT License
